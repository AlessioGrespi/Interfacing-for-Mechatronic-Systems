#include "stm32f3xx.h" 

void TIM3_IRQHandler(void);
void LEDsetupGPIOE(void);
void LEDtimerSetup(void);
void GPIOAsetup(void);
void DACsetup(void);
void ADCsetup(void);
void OpAmpStartUp(void);
void ADCread(void);
void PWMStartUp(void);
void SysConfig(void);
void EXTI0_IRQHandler(void);

int counter = 0;
void delay(int a); // prototype for delay function
unsigned int ADC1Value;
int test = 0;
		
int main(void)
{
	//LEDsetupGPIOE();
	//LEDtimerSetup();
	//GPIOAsetup();
	//DACsetup();
	//ADCsetup();
	//OpAmpStartUp();
	//PWMStartUp();
	SysConfig();
	
	// ---------------------------- END OF STARTUP -----------------------

		while (1)
  {
		//ADCread();
		//TIM3_IRQHandler();
		//GPIOE->BSRRL = (counter << 8); //shifts bits left by 8 spots, auto converts from decimal to hex
	//ARR is time period
	}
}

void LEDsetupGPIOE()
{
	RCC->AHBENR |= RCC_AHBENR_GPIOEEN;	 // Enable clock on GPIO port E
	GPIOE->MODER |= 0x55550000; // Set mode of each pin in port E
	GPIOE->OTYPER &= ~(0x00000000); // Set output type for each pin required in Port E
	GPIOE->PUPDR &= ~(0xffff0000); // Set Pull up/Pull down resistor configuration for Port E
}

void LEDtimerSetup()
{
	//LED Timer Setup
	RCC->APB1ENR |= RCC_APB1ENR_TIM3EN; //timer for LEDs
	TIM3->PSC = 799; // prescalor value in Timer ‘x’ as 100
	TIM3->ARR = 9999; // Auto-Reset Register of Timer ‘x’ set to 1000 counts
	TIM3->CR1 |= TIM_CR1_CEN; // timer start
	
	//Timer Interrupt setup
	TIM3->DIER |= TIM_DIER_UIE; // Set DIER register to watch out for an ‘Update’ Interrupt Enable (UIE) – or 0x00000001
	NVIC_EnableIRQ(TIM3_IRQn); // Enable Timer ‘x’ interrupt request in NVIC
}

void GPIOAsetup()
{
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN;	 // Enable clock on GPIO port A
	GPIOA->MODER |= 0x00000133; // GPIOA OpAmp(5 Input) DAC(4 Output) + OpAmp (2 Analog) ADC(0 Analog) Setup
	GPIOA->OTYPER &= ~(0x00000000); // Set output type for each pin required in Port A
	GPIOA->PUPDR &= ~(0x00000000); // Set Pull up/Pull down resistor configuration for Port A
}

void DACsetup()
{
	RCC->APB1ENR |= RCC_APB1ENR_DAC1EN; // enable APB1 clock
	DAC1->CR |= DAC_CR_BOFF1; //disable buffer for DAC register
	DAC1->CR |= DAC_CR_EN1; //enable DAC peripheral
}

void ADCsetup()
{
	ADC1->CR = 0x20000000;
	ADC1->CR |= 0x00000000; // enable voltage regulator
	delay(100);
	ADC1->CR |= 0x10000000;

	ADC1->CR &= ADC_CR_ADCALDIF;
	ADC1->CR |= ADC_CR_ADCAL; //Calibrate ADC

	RCC->CFGR2 |= RCC_CFGR2_ADCPRE12_DIV2; //enable clock to adc?
	RCC->AHBENR |= RCC_AHBENR_ADC12EN;
	ADC1_2_COMMON->CCR |= 0x00010000;

	ADC1->CFGR |= 0x00000010; //set analogue, 8bit, non cont
	ADC1->SQR1 |= 0x00000040; //multiplex, channel 7 length 1
	ADC1->SMPR1 |= 0x00000018; //7.5 adc clockcycles maybe 19.5 is better?
	
	ADC1->CR |= ADC_CR_ADEN; 
	
	while(ADC_ISR_ADRD == 0) //wait for high
	{
		delay(1);
	}
}

void OpAmpStartUp()
{
	RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN; //OpAmp clock
	//pin congig -> PA2 Analog, PA5, Input
	OPAMP1->CSR |= 0x00000001; //OpAmp enable
	OPAMP1->CSR |= 0x00000004; // PA.5 as non-inv. Input
	OPAMP1->CSR |= 0x00000040; // Set VM_SEL to 0b10 to enable PGA mode
	//OPAMP1->CSR |= OPAMP1_CSR_PGA_GAIN //PGA_GAIN bit value set
}

void ADCread()
{
	ADC1->CR |= ADC_CR_ADSTART; 
	while(ADC_ISR_EOC == 0); //wait for high

	ADC1Value = ADC1->DR;
}

void TIM3_IRQHandler()
{

	if ((TIM3->SR & TIM_SR_UIF) !=0) // Check interrupt source is from	the ‘Update’ interrupt flag
	{
		
		GPIOE->BSRRH = (0xFFFF); 
		counter++;
		DAC1->DHR12R1 = counter;
	
		
		GPIOE->BSRRL = (ADC1Value << 8); // wut is bitshift amount
	}
	
	TIM3->SR &= ~TIM_SR_UIF; // Reset ‘Update’ interrupt flag in the SR register
}





// Delay function to occupy processor
void delay (int a)
{
		volatile int i,j;

		for (i=0 ; i < a ; i++)
		{
				j++;
		}

		return;
}

void PWMStartUp ()
{
	RCC->AHBENR |= RCC_AHBENR_GPIOEEN;
	RCC->APB2ENR |= RCC_APB2ENR_TIM1EN;
	GPIOE->MODER |= 0X00080000;
	GPIOE->AFR[1] |= 0X00000020;
	TIM1->PSC = 99;
	TIM1->ARR = 79;
	TIM1->CCMR1 |= 0x00000060;
	TIM1->CCR1 = 10; // ONTIME FOR CLOCK PULES // THIS AFFECTS THE BRIGHTENESS
	//SET gpio PIN TO OUTPUT MOE IN TIMx_BDTR
	TIM1->BDTR |= TIM_BDTR_MOE;
	//enable channel to output in TIMx_CCER
	TIM1->CCER |= TIM_CCER_CC1E;
	//ENABLE TIMER
	TIM1->CR1 |= TIM_CR1_CEN;
	


	

	//Configure the required pin to be ‘alternate function’ with suitable transistor and resistor arrangements. Remember to connect the port to a system clock to activate it.
	//make pin that uses tim1 from afr register, look at afr tables GPIOE->AFR[0]|=0x00000200;

// use the arr and psc thingies for this new timer to make a 100Hz freq.



}

void SysConfig()
{
	RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN;
	EXTI->IMR |= EXTI_IMR_MR0;
	EXTI->RTSR |= EXTI_RTSR_TR0;
	SYSCFG->EXTICR[0] |= SYSCFG_EXTICR1_EXTI0_PA;

	
		
	//TIM1->DIER |= TIM_DIER_UIE; 
	NVIC_EnableIRQ(EXTI0_IRQn); // Enable Timer ‘x’ interrupt request in NVIC
	NVIC_SetPriority(EXTI0_IRQn, 0x00);
}


void EXTI0_IRQHandler()
{
	if (EXTI->PR & EXTI_PR_PR0) // check source
	{
		EXTI->PR |= EXTI_PR_PR0; // clear flag*
		// ENTER FUNCTION HERE
		test++;
	}
	//TIM1->SR &= ~TIM_SR_UIF; // Reset ‘Update’ interrupt flag in the SR register
}
