#include "stm32f3xx.h" 

void TIM3_IRQHandler(void);
void LEDsetupGPIOE(void);
void LEDtimerSetup(void);
void GPIOAsetup(void);
void DACsetup(void);
void ADCsetup(void);
void OpAmpStartUp(void);
void ADCread(void);
void PWMStartUp(void);
void SysConfig(void);
void EXTI0_IRQHandler(void);
void EXTI1_IRQHandler(void);
void EXTI1_TSC_IRQHandler(void);
void LEDUpdate(void);

int counter = 0;
void delay(int a); // prototype for delay function
unsigned int ADC1Value;
int test = 0;
int encoderCount = 0;
		
int main(void)
{
	LEDsetupGPIOE();
	//LEDtimerSetup();
	//GPIOAsetup();
	//DACsetup();
	//ADCsetup();
	//OpAmpStartUp();
	//PWMStartUp();
	SysConfig();
	
	// ---------------------------- END OF STARTUP -----------------------

		while (1)
  {

	}
}

void DACsetup()
{
	RCC->APB1ENR |= RCC_APB1ENR_DAC1EN; // enable APB1 clock
	DAC1->CR |= DAC_CR_BOFF1; //disable buffer for DAC register
	DAC1->CR |= DAC_CR_EN1; //enable DAC peripheral
}

void LEDupdate()
{
		encoderCount++;
	
		GPIOE->BSRRH = (0xFC00); //set to off
	
		if (encoderCount == 16)
		{
			encoderCount = 0;
		}
		
		GPIOE->BSRRL = encoderCount << 12; //11-14
}

void LEDsetupGPIOE()
{
	RCC->AHBENR |= RCC_AHBENR_GPIOEEN;	 // Enable clock on GPIO port E
	GPIOE->MODER |= 0x55550000; // Set mode of each pin in port E
	GPIOE->OTYPER &= ~(0x00000000); // Set output type for each pin required in Port E
	GPIOE->PUPDR &= ~(0xffff0000); // Set Pull up/Pull down resistor configuration for Port E
}

void setupGPIOA()
{
	RCC->AHBENR |= RCC_AHBENR_GPIOAEN;	 // Enable clock on GPIO port A
	GPIOA->MODER |= 0x00000000; // Set mode of each pin in port A
	GPIOA->OTYPER &= ~(0x00000000); // Set output type for each pin required in Port A
	GPIOA->PUPDR &= ~(0x00000000); // Set Pull up/Pull down resistor configuration for Port A
	//
	//GPIOA->IDR |= 0x00000002;
}

// Delay function to occupy processor
void delay (int a)
{
		volatile int i,j;

		for (i=0 ; i < a ; i++)
		{
				j++;
		}

		return;
}



void SysConfig()
{
	//button config
	RCC->APB2ENR |= RCC_APB2ENR_SYSCFGEN; //sysconfig connect to system clock so gpio interrupt work
	
	EXTI->IMR |= EXTI_IMR_MR0;
	EXTI->RTSR |= EXTI_RTSR_TR0;
	SYSCFG->EXTICR[0] |= SYSCFG_EXTICR1_EXTI0_PA;	//PA0
	
	//LEDA 
	EXTI->IMR |= EXTI_IMR_MR1;
	EXTI->RTSR |= EXTI_RTSR_TR1; //trigger on rise
	EXTI->FTSR |= EXTI_FTSR_TR1; //trigger on fall
	SYSCFG->EXTICR[1] |= SYSCFG_EXTICR1_EXTI1_PA;	//PA1
	
	//LEDB 
	EXTI->IMR |= EXTI_IMR_MR2;
	EXTI->RTSR |= EXTI_RTSR_TR2; //trigger on rise
	EXTI->FTSR |= EXTI_FTSR_TR2; //trigger on fall
	SYSCFG->EXTICR[2] |= SYSCFG_EXTICR1_EXTI2_PA;	//PA2
	
	NVIC_EnableIRQ(EXTI0_IRQn); // Enable Timer ‘x’ interrupt request in NVIC
	NVIC_SetPriority(EXTI0_IRQn, 0x00);
	
	NVIC_EnableIRQ(EXTI1_IRQn); // Enable Timer ‘x’ interrupt request in NVIC
	NVIC_SetPriority(EXTI1_IRQn, 0x00);
	
	NVIC_EnableIRQ(EXTI2_TSC_IRQn); // Enable Timer ‘x’ interrupt request in NVIC
	NVIC_SetPriority(EXTI2_TSC_IRQn, 0x00);
}


void EXTI0_IRQHandler()
{
	if (EXTI->PR & EXTI_PR_PR0) // check source
	{
				test++;
		EXTI->PR |= EXTI_PR_PR0; // clear flag*
		// ENTER FUNCTION HERE
		GPIOE->BSRRH = (0x300);
		switch(test)
		{
			case 1: //10
					GPIOE->BSRRL = (0x100);	
				break;
			case 2: //11
					GPIOE->BSRRL = (0x300);
				break;
			case 3:	//01
					GPIOE->BSRRL = (0x200);	
				break;
			case 4: //00
					test = 0;
					GPIOE->BSRRH = (0x300);
				break;
		}

	}
}


void EXTI1_IRQHandler()
{
	if (EXTI->PR & EXTI_PR_PR1) // check source
	{
		EXTI->PR |= EXTI_PR_PR1; // clear flag*
		// ENTER FUNCTION HERE	
		LEDupdate();
	}
};

void EXTI2_TSC_IRQHandler()
{
	if (EXTI->PR & EXTI_PR_PR2) // check source
	{
		EXTI->PR |= EXTI_PR_PR2; // clear flag*
		// ENTER FUNCTION HERE
		LEDupdate();
	}
};
